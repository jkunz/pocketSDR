/**
 * wsse
 * https://github.com/oumarPoulo/wsse-header
 *
 * Copyright 2015 Diallo Alpha Oumar Binta
 * Released under the MIT license
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['crypto-js', 'moment'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('crypto-js'), require('moment'));
  } else{
    root.wsse = factory(root.CryptoJS, root.moment);
  }
}(this, function (CryptoJS, moment) {
  console.log("jkunz version 1")
  'use strict';

  var wsse = {};

  /*BEING OMNITURE WSSE ENCODING*/
    var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
    var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
    var chrsz   = 8;   /* bits per input character. 8 - ASCII; 16 - Unicode      */

    function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
    function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
    function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
    function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
    function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
    function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

    function sha1_vm_test()
    {
      return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
    }

    function core_sha1(x, len)
    {
      x[len >> 5] |= 0x80 << (24 - len % 32);
      x[((len + 64 >> 9) << 4) + 15] = len;

      var w = Array(80);
      var a =  1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d =  271733878;
      var e = -1009589776;

      for(var i = 0; i < x.length; i += 16)
      {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        var olde = e;

        for(var j = 0; j < 80; j++)
        {
          if(j < 16) w[j] = x[i + j];
          else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
          var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                          safe_add(safe_add(e, w[j]), sha1_kt(j)));
          e = d;
          d = c;
          c = rol(b, 30);
          b = a;
          a = t;
        }

        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde);
      }
      return Array(a, b, c, d, e);

    }

    function sha1_ft(t, b, c, d)
    {
      if(t < 20) return (b & c) | ((~b) & d);
      if(t < 40) return b ^ c ^ d;
      if(t < 60) return (b & c) | (b & d) | (c & d);
      return b ^ c ^ d;
    }

    function sha1_kt(t)
    {
      return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
            (t < 60) ? -1894007588 : -899497514;
    }

    function core_hmac_sha1(key, data)
    {
      var bkey = str2binb(key);
      if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

      var ipad = Array(16), opad = Array(16);
      for(var i = 0; i < 16; i++)
      {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
      }

      var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
      return core_sha1(opad.concat(hash), 512 + 160);
    }

    function safe_add(x, y)
    {
      var lsw = (x & 0xFFFF) + (y & 0xFFFF);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 0xFFFF);
    }

    function rol(num, cnt)
    {
      return (num << cnt) | (num >>> (32 - cnt));
    }

    function str2binb(str)
    {
      var bin = Array();
      var mask = (1 << chrsz) - 1;
      for(var i = 0; i < str.length * chrsz; i += chrsz)
        bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i%32);
      return bin;
    }

    function binb2str(bin)
    {
      var str = "";
      var mask = (1 << chrsz) - 1;
      for(var i = 0; i < bin.length * 32; i += chrsz)
        str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
      return str;
    }

    function binb2hex(binarray)
    {
      var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
      var str = "";
      for(var i = 0; i < binarray.length * 4; i++)
      {
        str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
              hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
      }
      return str;
    }

    function binb2b64(binarray)
    {
      var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var str = "";
      for(var i = 0; i < binarray.length * 4; i += 3)
      {
        var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                    | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                    |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
        for(var j = 0; j < 4; j++)
        {
          if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
          else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
        }
      }
      return str;
    }

    var Base64 = {
      EncodeChars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      DecodeChars: new Array(
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
      ),

      encode: function(str) {
        var out, i, len;
        var c1, c2, c3;

        len = str.length;
        i = 0;
        out = "";
        while(i < len) {
        c1 = str.charCodeAt(i++) & 0xff;
        if(i == len)
        {
            out += Base64.EncodeChars.charAt(c1 >> 2);
            out += Base64.EncodeChars.charAt((c1 & 0x3) << 4);
            out += "==";
            break;
        }
        c2 = str.charCodeAt(i++);
        if(i == len)
        {
            out += Base64.EncodeChars.charAt(c1 >> 2);
            out += Base64.EncodeChars.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
            out += Base64.EncodeChars.charAt((c2 & 0xF) << 2);
            out += "=";
            break;
        }
        c3 = str.charCodeAt(i++);
        out += Base64.EncodeChars.charAt(c1 >> 2);
        out += Base64.EncodeChars.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
        out += Base64.EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6));
        out += Base64.EncodeChars.charAt(c3 & 0x3F);
        }
        return out;
      },

      decode: function(str) {
        var c1, c2, c3, c4;
        var i, len, out;

        len = str.length;
        i = 0;
        out = "";
        while(i < len) {
        /* c1 */
        do {
            c1 = Base64.DecodeChars[str.charCodeAt(i++) & 0xff];
        } while(i < len && c1 == -1);
        if(c1 == -1)
            break;

        /* c2 */
        do {
            c2 = Base64.DecodeChars[str.charCodeAt(i++) & 0xff];
        } while(i < len && c2 == -1);
        if(c2 == -1)
            break;

        out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));

        /* c3 */
        do {
            c3 = str.charCodeAt(i++) & 0xff;
            if(c3 == 61)
            return out;
            c3 = Base64.DecodeChars[c3];
        } while(i < len && c3 == -1);
        if(c3 == -1)
            break;

        out += String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));

        /* c4 */
        do {
            c4 = str.charCodeAt(i++) & 0xff;
            if(c4 == 61)
            return out;
            c4 = Base64.DecodeChars[c4];
        } while(i < len && c4 == -1);
        if(c4 == -1)
            break;
        out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
        }
        return out;
      }
    };
  /*END OMNITURE WSSE ENCODING*/

  wsse.buildWsseHeader = function(credentials) {
    var username = credentials.username;
    var passwordEncoded = credentials.passwordEncoded;
    var nonce = wsse.generateNonce(); 
    var createdDate = wsse.generateCreatedDate(); 
    var passwordDigest = b64_sha1(nonce + createdDate + passwordEncoded);
    nonce=Base64.encode(nonce);

    return 'UsernameToken Username="' + username + '", PasswordDigest="' + passwordDigest + '", Nonce="' + nonce + '", Created="' + createdDate + '"';
  };

  wsse.generateNonce = function() {
      var len = 24, chars  = "0123456789abcdef", nonce  = "";
      for (var i = 0; i < len; i++)
      {
          nonce += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      var result=nonce;
      return result
  };

  wsse.generateCreatedDate = function() {
        var date = new Date(), y, m, d, h, i, s;
        y = date.getUTCFullYear();
        m = (date.getUTCMonth() + 1); if (m < 10) { m = "0" + m; }
        d = (date.getUTCDate());      if (d < 10) { d = "0" + d; }
        h = (date.getUTCHours());     if (h < 10) { h = "0" + h; }
        i = (date.getUTCMinutes());   if (i < 10) { i = "0" + i; }
        s = (date.getUTCSeconds());   if (s < 10) { s = "0" + s; }
        return y + "-" + m + "-" + d + "T" + h + ":" + i + ":" + s + "Z";
    };

  wsse.setup = function(options) {
    console.log("passwordEncodingAsBase64:")
    options = options || {};
    wsse.passwordEncodingIterations = options.passwordEncodingIterations || 5000;
    wsse.secondsToSubtract = options.secondsToSubtract || 0;
    wsse.passwordEncodingAsBase64 = options.passwordEncodingAsBase64 === false ? false : true;
      console.log("passwordEncodingAsBase64:"+wsse.passwordEncodingAsBase64)
    wsse.useSaltOnDigest = (options.useSaltOnDigest === true) ? true : false;
  };

  wsse.buildHttpHeader = function(credentials) {
    var _wsseHeader = wsse.buildWsseHeader(credentials);
    var header = {
      'X-WSSE': _wsseHeader
    };

    return header;
  };

  return wsse;
}));
